#include <bits/stdc++.h>
using namespace std;

/*
Approach:
1. We use Disjoint Set Union (DSU) to group nodes into connected components.
2. For each component, we track:
   - The total number of nodes.
   - How many of them are initially infected.
3. If a component has more than 1 infected node, removing one won’t stop the infection.
4. If a component has exactly 1 infected node, removing it prevents the entire component from being infected.
5. We try removing each initially infected node and calculate how many infections we can avoid.
6. The answer is the infected node whose removal minimizes the spread. If multiple nodes tie, the smallest index is chosen.

Time Complexity: O(N^2 + N log N)  
- Building DSU with adjacency matrix takes O(N^2).  
- Sorting initial infected list takes O(N log N).  
- Rest of the operations are near O(N).  

Space Complexity: O(N)  
- DSU arrays and maps store parent, rank, and infection info for each node.
*/

class Solution {
public:
    class DisjointSetUnion {
        vector<int> parent;
        vector<int> rank;
        unordered_map<int, int> total_nodes_in_component; // component size
        unordered_map<int, int> total_infected;           // infected nodes count per component

    public:
        DisjointSetUnion(int n) {
            parent.resize(n);
            rank.resize(n, 0);

            for (int i = 0; i < n; i++) {
                parent[i] = i;
                total_nodes_in_component[i] = 1;
            }
        }

        // Path compression + find ultimate parent of a node
        int find_ultimate_parent(int node) {
            if (parent[node] == node) {
                return node;
            }
            return parent[node] = find_ultimate_parent(parent[node]);
        }

        // Union two nodes into one component by rank
        void unite_two_nodes(int node_1, int node_2) {
            int ult_p_1 = find_ultimate_parent(node_1);
            int ult_p_2 = find_ultimate_parent(node_2);

            if (ult_p_1 == ult_p_2) {
                return; // already in the same component
            }

            if (rank[ult_p_1] == rank[ult_p_2]) {
                parent[ult_p_1] = ult_p_2;
                rank[ult_p_2]++;
                total_nodes_in_component[ult_p_2]++;
            } else if (rank[ult_p_1] < rank[ult_p_2]) {
                parent[ult_p_1] = ult_p_2;
                total_nodes_in_component[ult_p_2]++;
            } else {
                parent[ult_p_2] = ult_p_1;
                total_nodes_in_component[ult_p_1]++;
            }
        }

        // Return total number of nodes in a component
        int find_total_nodes(int leader) {
            return total_nodes_in_component[leader];
        }

        // Mark a node (and hence its component) as infected
        void make_infected(int node) {
            int baap = find_ultimate_parent(node);
            total_infected[baap]++;
        }

        // Return how many infected nodes are in a node’s component
        int ans(int node) {
            int baap = find_ultimate_parent(node);
            if (total_infected.find(baap) == total_infected.end()) {
                return 0;
            }
            return total_infected[baap];
        }
    };

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        DisjointSetUnion dsu(n);

        // Build components using DSU
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && graph[i][j] == 1) {
                    if (dsu.find_ultimate_parent(i) != dsu.find_ultimate_parent(j)) {
                        dsu.unite_two_nodes(i, j);
                    }
                }
            }
        }

        // Sort to ensure smallest index chosen in case of tie
        sort(initial.begin(), initial.end());

        // Mark initially infected nodes
        for (int node : initial) {
            dsu.make_infected(node);
        }

        int total_infected_initial = 0;
        vector<int> visited(n, false);

        // Count how many nodes are infected overall
        for (int node : initial) {
            int leader = dsu.find_ultimate_parent(node);
            int in_this_comp_inf = dsu.ans(leader);

            if (in_this_comp_inf != 0 && visited[leader] == false) {
                visited[leader] = true;
                int size_of_component = dsu.find_total_nodes(leader);
                total_infected_initial += size_of_component;
            }
        }

        int final_ans = initial[0];
        int minimum_ans = total_infected_initial;

        // Try removing each infected node
        for (int node : initial) {
            int leader = dsu.find_ultimate_parent(node);
            int in_this_comp_inf = dsu.ans(leader);

            if (in_this_comp_inf != 1) {
                // If more than one infected in this component,
                // removing this node won’t help.
                continue;
            } else {
                // If exactly one infected in this component,
                // removing it saves the entire component.
                int component_size = dsu.find_total_nodes(leader);
                int current_total_infected = total_infected_initial - component_size;

                if (current_total_infected < minimum_ans) {
                    minimum_ans = current_total_infected;
                    final_ans = node;
                }
            }
        }

        return final_ans;
    }
};
